import dash_core_components as dcc
import dash_html_components as html
import dash_bootstrap_components as dbc
import plotly.graph_objects as go
import pandas as pd

start, fig = None, None
zoom_default = 4

map_token = 'pk.eyJ1IjoiZG11cmFraG92c2t5aSIsImEiOiJja29jeG9wbDQwdjh1Mm9wZ3Bvbm1ndmYzIn0.qeqHa9f5UB3iY0_vdhiXgA'

df = pd.read_excel("gps.xlsx", index_col=0)
df = df.sort_values(by='city', ascending=True)
df['city'] = df.index


def dashboard(zoom=zoom_default):
    global start, df
    start = list(df.city)[0]
    layout = dbc.Container([
        dbc.Row([
            dbc.Col([controls()], md=3, width='auto'),
            dbc.Col(id='board', children=[board(zoom=zoom)], md=9, width='auto')
        ])

    ], fluid=True)

    return layout


def controls():
    """
    Generate control panel of the page
    :return:
    """
    cities = list(df.city)
    start_drop = [{'label': c + '\n', 'value': c} for c in cities]
    main_controls = dbc.Card([
        html.Label(id='list-label', children=['City list'], style={'font-weight': 'bold'}),
        dcc.Checklist(id='cities-list',
                      options=start_drop, value=[c for c in cities],
                      labelStyle=dict(display='block'),
                      style={'height': '12rem', 'overflow-y': 'scroll', 'margin-bottom': '15px'}),
        html.Label(id='start-label', children=['Home city'], style={'font-weight': 'bold'}),
        dcc.Dropdown(id='start-id',
                     options=[],
                     value=None,
                     multi=False,
                     style={'margin-bottom': '10px'}),
        html.Div([
            dbc.Button('Run', id='launch', color='success', className='mr-1',
                       style={'width': '90px'}),
            dbc.Button('Reset', id='reset', color='primary', className='mr-1',
                       style={'width': '90px'})
        ], style={'margin': 'auto'})
    ], style={'width': '18rem', 'height': '23rem', "margin-top": "30px"}, body=True)
    return main_controls


def board(selected_cities=None,
          st=None,
          path=None,
          zoom=zoom_default):
    """
    Return main graph
    :param selected_cities: cities, selected in the listbox
    :param st: start city, selected in the combobox
    :param path: The path generated by the algorithm, if any
    :param zoom: zoom-value of the main graph. Default value is set as a global constant
    :return: dash component Graph with the figure
    """
    global fig, start, df
    if selected_cities is None:
        selected_cities = list(df.city)

    if not st:
        st = start
    else:
        start = st

    start_df = df.loc[df.city == st].copy()

    return dcc.Graph(id='main-graph', figure=fig_map(selected_cities, start_df, path, zoom=zoom), style={"margin-top": "30px"})


def fig_map(selected_cities, start_df, path=None, zoom=zoom_default):
    """
    Generates full figure with a path or base figure without any path
    """
    global df

    cities = list(df.city)

    if path:
        fig = base_map(selected_cities, start_df)
        connect = df.loc[df.city.isin(path)]
        connect = connect.reindex(index=path)
        fig.add_trace(go.Scattermapbox(
            lat=connect.lat,
            lon=connect.long,
            mode='lines',
            line=go.scattermapbox.Line(
                color='yellow',
                width=3
            ),
            text=connect.city,
            hoverinfo='text'
        ))
        fig.update_layout(
            autosize=True,
            hovermode='closest',
            showlegend=False,
            margin_l=0,
            margin_t=0,
            mapbox=dict(
                accesstoken=map_token,
                bearing=0,
                center=dict(
                    lat=df.lat.mean(),
                    lon=df.long.mean(),
                ),
                pitch=0,
                zoom=zoom,
                style='light'
            ),
        )
        return fig
    else:
        return base_map(selected_cities, start_df, zoom=zoom)


def base_map(selected_cities, start_df, zoom=zoom_default):
    global df
    cities = df.copy()
    selected_cities = df.loc[df.city.isin(selected_cities)]
    fig = go.Figure()
    fig.add_trace(go.Scattermapbox(
                                    lat=start_df.lat,
                                    lon=start_df.long,
                                    mode='markers',
                                    marker=go.scattermapbox.Marker(
                                        size=17,
                                        color='green',
                                        opacity=0.7
                                    ),
                                    text=start_df.city,
                                    hoverinfo='text'
                                    ))
    fig.add_trace(go.Scattermapbox(
                                    lat=selected_cities.lat,
                                    lon=selected_cities.long,
                                    mode='markers',
                                    marker=go.scattermapbox.Marker(
                                        size=12,
                                        color='blue',
                                        opacity=0.7
                                    ),
                                    text=selected_cities.city,
                                    hoverinfo='text'
                                    ))
    fig.add_trace(go.Scattermapbox(
                                    lat=cities.lat,
                                    lon=cities.long,
                                    mode='markers',
                                    marker=go.scattermapbox.Marker(
                                        size=6,
                                        color='magenta',
                                        opacity=0.7
                                    ),
                                    text=cities.city,
                                    hoverinfo='text'
                                    ))
    fig.update_layout(
        autosize=True,
        hovermode='closest',
        showlegend=False,
        margin_l=0,
        margin_t=0,
        mapbox=dict(
            accesstoken=map_token,
            bearing=0,
            center=dict(
                lat=cities.lat.mean(),
                lon=cities.long.mean(),
            ),
            pitch=0,
            zoom=zoom,
            style='light'
        ),
    )

    return fig